From 4272ace1f5ea144b43614e68439591b5ad531b4f Mon Sep 17 00:00:00 2001
From: Icenowy Zheng <uwu@icenowy.me>
Date: Mon, 1 Sep 2025 14:12:26 +0800
Subject: [PATCH] zink: drop the requirement of nullDescriptor

The nullDescriptor feature isn't present on the proprietary drivers for
Imagination PowerVR GPUs with Rogue architecture (neither on the
open-source driver).

Re-add the fallback codepath of using dummy surfaces, and add a debug
option to force this fallback codepath.

This partially reverts commit 0a2c3953948 ("zink: require nullDescriptor
feature").

Signed-off-by: Icenowy Zheng <uwu@icenowy.me>
---
 docs/drivers/zink.rst                        |   2 +
 src/gallium/drivers/zink/zink_context.c      | 170 ++++++++++++++++---
 src/gallium/drivers/zink/zink_context.h      |   3 +
 src/gallium/drivers/zink/zink_device_info.py |   2 +-
 src/gallium/drivers/zink/zink_draw.cpp       |   2 +-
 src/gallium/drivers/zink/zink_screen.c       |  14 +-
 src/gallium/drivers/zink/zink_types.h        |   4 +
 7 files changed, 167 insertions(+), 30 deletions(-)

diff --git a/docs/drivers/zink.rst b/docs/drivers/zink.rst
index b870b78b394c2..294f49f282fba 100644
--- a/docs/drivers/zink.rst
+++ b/docs/drivers/zink.rst
@@ -331,6 +331,8 @@ variable:
     Zap renderpass loads for DONT_CARE
   ``nogeneral``
     Disable GENERAL layout usage for supported hardware
+  ``dummydes``
+    Always use dummy descriptors even if nullDescriptor feature is available
 
 Vulkan Validation Layers
 ^^^^^^^^^^^^^^^^^^^^^^^^
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 889699d80f2c4..5c478a2e4400c 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -165,8 +165,12 @@ zink_context_destroy(struct pipe_context *pctx)
    if (ctx->blitter)
       util_blitter_destroy(ctx->blitter);
 
+   pipe_resource_reference(&ctx->dummy_vertex_buffer, NULL);
    pipe_resource_reference(&ctx->dummy_xfb_buffer, NULL);
 
+   for (unsigned i = 0; i < ARRAY_SIZE(ctx->dummy_fb_buffers); i++)
+      pipe_resource_reference(&ctx->dummy_fb_buffers[i], NULL);
+
    zink_descriptors_deinit_bindless(ctx);
 
    u_upload_destroy(pctx->stream_uploader);
@@ -724,7 +728,9 @@ update_descriptor_state_ubo_lazy(struct zink_context *ctx, mesa_shader_stage sha
       }
 #endif
    } else {
-      ctx->di.t.ubos[shader][slot].buffer = VK_NULL_HANDLE;
+      bool have_null_descriptors = screen->info.rb2_feats.nullDescriptor && !(zink_debug & ZINK_DEBUG_DUMMYDES);
+      VkBuffer null_buffer = zink_resource(ctx->dummy_vertex_buffer)->obj->buffer;
+      ctx->di.t.ubos[shader][slot].buffer = have_null_descriptors ? VK_NULL_HANDLE : null_buffer;
       ctx->di.t.ubos[shader][slot].range = VK_WHOLE_SIZE;
    }
    return res;
@@ -747,13 +753,16 @@ update_descriptor_state_ssbo_db(struct zink_context *ctx, mesa_shader_stage shad
 ALWAYS_INLINE static struct zink_resource *
 update_descriptor_state_ssbo_lazy(struct zink_context *ctx, mesa_shader_stage shader, unsigned slot, struct zink_resource *res)
 {
+   struct zink_screen *screen = zink_screen(ctx->base.screen);
    ctx->di.t.ssbos[shader][slot].offset = ctx->ssbos[shader][slot].buffer_offset;
    ctx->di.descriptor_res[ZINK_DESCRIPTOR_TYPE_SSBO][shader][slot] = res;
    if (res) {
       ctx->di.t.ssbos[shader][slot].buffer = res->obj->buffer;
       ctx->di.t.ssbos[shader][slot].range = ctx->ssbos[shader][slot].buffer_size;
    } else {
-      ctx->di.t.ssbos[shader][slot].buffer = VK_NULL_HANDLE;
+      bool have_null_descriptors = screen->info.rb2_feats.nullDescriptor && !(zink_debug & ZINK_DEBUG_DUMMYDES);
+      VkBuffer null_buffer = zink_resource(ctx->dummy_vertex_buffer)->obj->buffer;
+      ctx->di.t.ssbos[shader][slot].buffer = have_null_descriptors ? VK_NULL_HANDLE : null_buffer;
       ctx->di.t.ssbos[shader][slot].range = VK_WHOLE_SIZE;
    }
    return res;
@@ -770,6 +779,7 @@ ALWAYS_INLINE static struct zink_resource *
 update_descriptor_state_sampler(struct zink_context *ctx, mesa_shader_stage shader, unsigned slot, struct zink_resource *res)
 {
    struct zink_screen *screen = zink_screen(ctx->base.screen);
+   bool have_null_descriptors = screen->info.rb2_feats.nullDescriptor && !(zink_debug & ZINK_DEBUG_DUMMYDES);
    const enum zink_descriptor_type type = ZINK_DESCRIPTOR_TYPE_SAMPLER_VIEW;
    ctx->di.descriptor_res[type][shader][slot] = res;
    if (res) {
@@ -800,13 +810,22 @@ update_descriptor_state_sampler(struct zink_context *ctx, mesa_shader_stage shad
          }
       }
    } else {
-      ctx->di.textures[shader][slot].imageView = VK_NULL_HANDLE;
-      ctx->di.textures[shader][slot].imageLayout = VK_IMAGE_LAYOUT_UNDEFINED;
-      if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
-         ctx->di.db.tbos[shader][slot].address = 0;
-         ctx->di.db.tbos[shader][slot].range = VK_WHOLE_SIZE;
+      if (likely(have_null_descriptors)) {
+         ctx->di.textures[shader][slot].imageView = VK_NULL_HANDLE;
+         ctx->di.textures[shader][slot].imageLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+         if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
+            ctx->di.db.tbos[shader][slot].address = 0;
+            ctx->di.db.tbos[shader][slot].range = VK_WHOLE_SIZE;
+         } else {
+            ctx->di.t.tbos[shader][slot] = VK_NULL_HANDLE;
+         }
       } else {
-         ctx->di.t.tbos[shader][slot] = VK_NULL_HANDLE;
+         assert(zink_descriptor_mode != ZINK_DESCRIPTOR_MODE_DB);
+         struct zink_surface *null_surface = zink_get_dummy_surface(ctx, 0);
+         struct zink_buffer_view *null_bufferview = ctx->dummy_bufferview;
+         ctx->di.textures[shader][slot].imageView = null_surface->image_view;
+         ctx->di.textures[shader][slot].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+         ctx->di.t.tbos[shader][slot] = null_bufferview->buffer_view;
       }
    }
    return res;
@@ -823,6 +842,7 @@ ALWAYS_INLINE static struct zink_resource *
 update_descriptor_state_image(struct zink_context *ctx, mesa_shader_stage shader, unsigned slot, struct zink_resource *res)
 {
    struct zink_screen *screen = zink_screen(ctx->base.screen);
+   bool have_null_descriptors = screen->info.rb2_feats.nullDescriptor && !(zink_debug & ZINK_DEBUG_DUMMYDES);
    const enum zink_descriptor_type type = ZINK_DESCRIPTOR_TYPE_IMAGE;
    ctx->di.descriptor_res[type][shader][slot] = res;
    if (res) {
@@ -842,12 +862,21 @@ update_descriptor_state_image(struct zink_context *ctx, mesa_shader_stage shader
          ctx->di.images[shader][slot].imageView = surface->image_view;
       }
    } else {
-      memset(&ctx->di.images[shader][slot], 0, sizeof(ctx->di.images[shader][slot]));
-      if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
-         ctx->di.db.texel_images[shader][slot].address = 0;
-         ctx->di.db.texel_images[shader][slot].range = VK_WHOLE_SIZE;
+      if (likely(have_null_descriptors)) {
+         memset(&ctx->di.images[shader][slot], 0, sizeof(ctx->di.images[shader][slot]));
+         if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
+            ctx->di.db.texel_images[shader][slot].address = 0;
+            ctx->di.db.texel_images[shader][slot].range = VK_WHOLE_SIZE;
+         } else {
+            ctx->di.t.texel_images[shader][slot] = VK_NULL_HANDLE;
+         }
       } else {
-         ctx->di.t.texel_images[shader][slot] = VK_NULL_HANDLE;
+         assert(zink_descriptor_mode != ZINK_DESCRIPTOR_MODE_DB);
+         struct zink_surface *null_surface = zink_get_dummy_surface(ctx, 0);
+         struct zink_buffer_view *null_bufferview = ctx->dummy_bufferview;
+         ctx->di.images[shader][slot].imageView = null_surface->image_view;
+         ctx->di.images[shader][slot].imageLayout = VK_IMAGE_LAYOUT_GENERAL;
+         ctx->di.t.texel_images[shader][slot] = null_bufferview->buffer_view;
       }
    }
    return res;
@@ -2519,17 +2548,36 @@ zink_delete_texture_handle(struct pipe_context *pctx, uint64_t handle)
 static void
 zero_bindless_descriptor(struct zink_context *ctx, uint32_t handle, bool is_buffer, bool is_image)
 {
-   if (is_buffer) {
-      if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
-         ctx->di.bindless[is_image].db.buffer_infos[handle].address = 0;
-         ctx->di.bindless[is_image].db.buffer_infos[handle].range = 0;
+   if (likely(zink_screen(ctx->base.screen)->info.rb2_feats.nullDescriptor && !(zink_debug & ZINK_DEBUG_DUMMYDES))) {
+      if (is_buffer) {
+         if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
+            ctx->di.bindless[is_image].db.buffer_infos[handle].address = 0;
+            ctx->di.bindless[is_image].db.buffer_infos[handle].range = 0;
+         } else {
+            VkBufferView *bv = &ctx->di.bindless[is_image].t.buffer_infos[handle];
+            *bv = VK_NULL_HANDLE;
+         }
       } else {
-         VkBufferView *bv = &ctx->di.bindless[is_image].t.buffer_infos[handle];
-         *bv = VK_NULL_HANDLE;
+         VkDescriptorImageInfo *ii = &ctx->di.bindless[is_image].img_infos[handle];
+         memset(ii, 0, sizeof(*ii));
       }
    } else {
-      VkDescriptorImageInfo *ii = &ctx->di.bindless[is_image].img_infos[handle];
-      memset(ii, 0, sizeof(*ii));
+      if (is_buffer) {
+         if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
+            ctx->di.bindless[is_image].db.buffer_infos[handle].address = zink_resource(ctx->dummy_bufferview->pres)->obj->bda;
+            ctx->di.bindless[is_image].db.buffer_infos[handle].range = 1;
+         } else {
+            VkBufferView *bv = &ctx->di.bindless[is_image].t.buffer_infos[handle];
+            struct zink_buffer_view *null_bufferview = ctx->dummy_bufferview;
+            *bv = null_bufferview->buffer_view;
+         }
+      } else {
+         struct zink_surface *null_surface = zink_get_dummy_surface(ctx, 0);
+         VkDescriptorImageInfo *ii = &ctx->di.bindless[is_image].img_infos[handle];
+         ii->sampler = VK_NULL_HANDLE;
+         ii->imageView = null_surface->image_view;
+         ii->imageLayout = VK_IMAGE_LAYOUT_GENERAL;
+      }
    }
 }
 
@@ -2849,13 +2897,15 @@ bool
 zink_update_fbfetch(struct zink_context *ctx)
 {
    const bool had_fbfetch = ctx->di.fbfetch.imageLayout == VK_IMAGE_LAYOUT_GENERAL;
+   bool have_null_descriptors = zink_screen(ctx->base.screen)->info.rb2_feats.nullDescriptor && !(zink_debug & ZINK_DEBUG_DUMMYDES);
    if (!ctx->gfx_stages[MESA_SHADER_FRAGMENT] ||
        !ctx->gfx_stages[MESA_SHADER_FRAGMENT]->info.fs.uses_fbfetch_output) {
       if (!had_fbfetch)
          return false;
       zink_batch_no_rp(ctx);
       ctx->di.fbfetch.imageLayout = VK_IMAGE_LAYOUT_UNDEFINED;
-      ctx->di.fbfetch.imageView = VK_NULL_HANDLE;
+      ctx->di.fbfetch.imageView = have_null_descriptors ? VK_NULL_HANDLE :
+                                  zink_get_dummy_surface(ctx, 0)->image_view;
       ctx->invalidate_descriptor_state(ctx, MESA_SHADER_FRAGMENT, ZINK_DESCRIPTOR_TYPE_UBO, 0, 1);
       return true;
    }
@@ -2874,7 +2924,8 @@ zink_update_fbfetch(struct zink_context *ctx)
       if (zink_get_fs_base_key(ctx)->fbfetch_ms != fbfetch_ms)
          zink_set_fs_base_key(ctx)->fbfetch_ms = fbfetch_ms;
    } else {
-      ctx->di.fbfetch.imageView = VK_NULL_HANDLE;
+      ctx->di.fbfetch.imageView = have_null_descriptors ? VK_NULL_HANDLE :
+                                  zink_get_dummy_surface(ctx, 0)->image_view;
    }
    bool ret = false;
    ctx->di.fbfetch.imageLayout = VK_IMAGE_LAYOUT_GENERAL;
@@ -5493,6 +5544,70 @@ zink_emit_string_marker(struct pipe_context *pctx,
    free(temp);
 }
 
+static struct pipe_resource *
+zink_create_dummy_fbbuf(struct zink_context *ctx, enum pipe_texture_target target, unsigned width, unsigned height, unsigned samples)
+{
+   struct pipe_resource *pres;
+   struct pipe_resource templ = {0};
+   templ.width0 = width;
+   templ.height0 = height;
+   templ.depth0 = 1;
+   templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
+   templ.target = target;
+   templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
+   if (samples < 2)
+      templ.bind |= PIPE_BIND_SHADER_IMAGE;
+   templ.nr_samples = samples;
+
+   pres = ctx->base.screen->resource_create(ctx->base.screen, &templ);
+   if (!pres)
+      return NULL;
+
+   return pres;
+}
+
+static struct pipe_resource *
+zink_get_dummy_fbbuf(struct zink_context *ctx, int samples_index)
+{
+   unsigned size = calc_max_dummy_fbo_size(ctx);
+   bool needs_null_init = false;
+   if (ctx->dummy_fb_buffers[samples_index]) {
+      /* delete old surface if ETOOSMALL */
+      struct zink_resource *res = zink_resource(ctx->dummy_fb_buffers[samples_index]);
+      if (res->base.b.width0 < size || res->base.b.height0 < size) {
+         pipe_resource_reference(&ctx->dummy_fb_buffers[samples_index], NULL);
+         needs_null_init = !samples_index && ctx->di.null_fbfetch_init;
+         if (!samples_index)
+            ctx->di.null_fbfetch_init = false;
+      }
+   }
+   if (!ctx->dummy_fb_buffers[samples_index]) {
+      ctx->dummy_fb_buffers[samples_index] = zink_create_dummy_fbbuf(ctx, PIPE_TEXTURE_2D, size, size, BITFIELD_BIT(samples_index));
+      assert(ctx->dummy_fb_buffers[samples_index]);
+      /* This is possibly used with imageLoad which according to GL spec must return 0 */
+      if (!samples_index) {
+         union pipe_color_union color = {0};
+         struct pipe_box box;
+         u_box_2d(0, 0, size, size, &box);
+         ctx->base.clear_texture(&ctx->base, ctx->dummy_fb_buffers[samples_index], 0, &box, &color);
+      }
+   }
+   if (needs_null_init)
+      init_null_fbfetch(ctx);
+   return ctx->dummy_fb_buffers[samples_index];
+}
+
+struct zink_surface *
+zink_get_dummy_surface(struct zink_context *ctx, int samples_index)
+{
+   struct pipe_surface templ = {0};
+
+   templ.format = PIPE_FORMAT_R8G8B8A8_UNORM;
+   templ.nr_samples = 0;
+   templ.texture = zink_get_dummy_fbbuf(ctx, samples_index);
+   return zink_create_fb_surface(&ctx->base, &templ);
+}
+
 static void
 zink_tc_parse_dsa(void *state, struct tc_renderpass_info *info)
 {
@@ -5717,12 +5832,20 @@ zink_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
 
    const uint32_t data[] = {0};
    if (!is_copy_only) {
+      ctx->dummy_vertex_buffer = pipe_buffer_create(&screen->base,
+         PIPE_BIND_VERTEX_BUFFER | PIPE_BIND_SHADER_IMAGE, PIPE_USAGE_IMMUTABLE, sizeof(data));
+      if (!ctx->dummy_vertex_buffer)
+         goto fail;
       ctx->dummy_xfb_buffer = pipe_buffer_create(&screen->base,
          PIPE_BIND_STREAM_OUTPUT, PIPE_USAGE_IMMUTABLE, sizeof(data));
       if (!ctx->dummy_xfb_buffer)
          goto fail;
    }
    if (!is_copy_only) {
+      ctx->dummy_bufferview = get_buffer_view(ctx, zink_resource(ctx->dummy_vertex_buffer), PIPE_FORMAT_R8G8B8A8_UNORM, 0, sizeof(data));
+      if (!ctx->dummy_bufferview)
+         goto fail;
+
       if (!zink_descriptors_init(ctx))
          goto fail;
    }
@@ -5779,6 +5902,7 @@ zink_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
    else
       ctx->invalidate_descriptor_state = zink_context_invalidate_descriptor_state;
    if (!is_copy_only && !is_compute_only) {
+      pipe_buffer_write_nooverlap(&ctx->base, ctx->dummy_vertex_buffer, 0, sizeof(data), data);
       pipe_buffer_write_nooverlap(&ctx->base, ctx->dummy_xfb_buffer, 0, sizeof(data), data);
       if (screen->info.have_EXT_color_write_enable)
          reapply_color_write(ctx);
diff --git a/src/gallium/drivers/zink/zink_context.h b/src/gallium/drivers/zink/zink_context.h
index 814077e6144c3..97bd90ae9649a 100644
--- a/src/gallium/drivers/zink/zink_context.h
+++ b/src/gallium/drivers/zink/zink_context.h
@@ -301,6 +301,9 @@ zink_clamp_void_swizzle(const struct util_format_description *desc, enum pipe_sw
 bool
 zink_resource_rebind(struct zink_context *ctx, struct zink_resource *res);
 
+struct zink_surface *
+zink_get_dummy_surface(struct zink_context *ctx, int samples_index);
+
 void
 zink_set_null_fs(struct zink_context *ctx);
 
diff --git a/src/gallium/drivers/zink/zink_device_info.py b/src/gallium/drivers/zink/zink_device_info.py
index cbd3fefb76412..06462868d5204 100644
--- a/src/gallium/drivers/zink/zink_device_info.py
+++ b/src/gallium/drivers/zink/zink_device_info.py
@@ -185,7 +185,7 @@ EXTENSIONS = [
               alias="rb2",
               properties=True,
               features=True,
-              conditions=["$feats.nullDescriptor"]),
+              conditions=["($feats.nullDescriptor && !(zink_debug & ZINK_DEBUG_DUMMYDES))"]),
     Extension("VK_EXT_image_robustness",
               alias="rb_image",
               features=True),
diff --git a/src/gallium/drivers/zink/zink_draw.cpp b/src/gallium/drivers/zink/zink_draw.cpp
index 090b48a823ac9..23686b4ce4a53 100644
--- a/src/gallium/drivers/zink/zink_draw.cpp
+++ b/src/gallium/drivers/zink/zink_draw.cpp
@@ -130,7 +130,7 @@ zink_bind_vertex_buffers(struct zink_context *ctx)
          buffers[i] = res->obj->buffer;
          buffer_offsets[i] = vb->buffer_offset;
       } else {
-         buffers[i] = VK_NULL_HANDLE;
+         buffers[i] = zink_resource(ctx->dummy_vertex_buffer)->obj->buffer;
          buffer_offsets[i] = 0;
       }
    }
diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index 1dddcf9ee903c..4b98987d3451d 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -119,6 +119,7 @@ zink_debug_options[] = {
    { "msaaopt", ZINK_DEBUG_MSAAOPT, "Optimize out loads/stores of MSAA attachments" },
    { "rploads", ZINK_DEBUG_RPLOADS, "Zap renderpass loads for DONT_CARE" },
    { "nogeneral", ZINK_DEBUG_NOGENERAL, "Disable GENERAL layout usage for supported hardware" },
+   { "dummydes", ZINK_DEBUG_DUMMYDES, "Use dummy descriptors even if nullDescriptor is available" },
    DEBUG_NAMED_VALUE_END
 };
 
@@ -3445,11 +3446,6 @@ zink_internal_create_screen(const struct pipe_screen_config *config, int64_t dev
       goto fail;
    }
 
-   if (!screen->info.rb2_feats.nullDescriptor) {
-      mesa_loge("Zink requires the nullDescriptor feature of KHR/EXT robustness2.");
-      goto fail;
-   }
-
    if (zink_set_driver_strings(screen)) {
       mesa_loge("ZINK: failed to set driver strings\n");
       goto fail;
@@ -3688,6 +3684,14 @@ zink_internal_create_screen(const struct pipe_screen_config *config, int64_t dev
          }
          can_db = false;
       }
+      if (!screen->info.rb2_feats.nullDescriptor || (zink_debug & ZINK_DEBUG_DUMMYDES)) {
+         if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
+            if (!screen->driver_name_is_inferred)
+               mesa_loge("Cannot use db descriptor mode without robustness2.nullDescriptor");
+            goto fail;
+         }
+         can_db = false;
+      }
       if (ZINK_FBFETCH_DESCRIPTOR_SIZE < screen->info.db_props.inputAttachmentDescriptorSize) {
          if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
             if (!screen->driver_name_is_inferred)
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index c174930e83b63..5974af9ddbe7f 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -253,6 +253,7 @@ enum zink_debug {
    ZINK_DEBUG_MSAAOPT = (1<<20),
    ZINK_DEBUG_RPLOADS = (1<<21),
    ZINK_DEBUG_NOGENERAL = (1<<22),
+   ZINK_DEBUG_DUMMYDES = (1<<23),
 };
 
 enum zink_pv_emulation_primitive {
@@ -1884,7 +1885,10 @@ struct zink_context {
       uint64_t render_passes;
    } hud;
 
+   struct pipe_resource *dummy_vertex_buffer;
    struct pipe_resource *dummy_xfb_buffer;
+   struct pipe_resource *dummy_fb_buffers[7];
+   struct zink_buffer_view *dummy_bufferview;
 
    unsigned buffer_rebind_counter;
    unsigned image_rebind_counter;
-- 
GitLab

